// Copyright 2015 runtime.js project authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

'use strict';

var isaac = require('../../deps/isaac/isaac');

// isaac.js returns crazy numbers, both positive and negative.
// This function is called on an isaac.rand() call,
// It gets the number to qualify for all of the following:
//  * Positive,
//  * Whole number,
//  * 0 < n < 256
// This ensures the numbers are similar to the numbers
// generated by VirtioRNG.
function isaacRound(n) {
  // Ensure it's positive
  if (n < 0) n = -n;
  // 0 < n < 256
  while (n > 256) n /= 4;
  // Whole number
  n = Math.round(n);

  return n;
}

var def = 'none';
var sources = {
  // If there are no methods specified and someone requests randomness,
  // use the default 'none' method which uses isaac.rand().
  // isaac.js uses Math.random as the initial seed (which does not use true
  // randomness), that's why as soon as the VirtioRNG device loads,
  // it sets itself as the default, since it uses true randomness.
  'none': {
    queue: [],
    init: function() {
      for (var i = 0; i < 256; i++) {
        sources['none'].queue.push(isaacRound(isaac.rand()));
      }
    },
    realRand: function(cb) {
      for (var i = 0; i < 256; i++) {
        sources['none'].queue.push(isaacRound(isaac.rand()));
      }
      cb();
    },
    seed: function() {
      return isaacRound(isaac.rand());
    },
    fillQueue: function() {
      for (var i = 0; i < 256; i++) {
        sources['none'].queue.push(isaacRound(isaac.rand()));
      }
    }
  }
};

sources['none'].init();

module.exports = {
  addSource: function(name, obj) {
    sources[name] = obj;
    sources[name].init();
  },
  setDefault: function(name) {
    if (!sources[name]) {
      return false;
    }

    def = name;
    return true;
  },
  rand: function(length, cb) {
    // Works like /dev/random, always waits for real randomness.

    if (typeof length === 'undefined') {
      length = 1;
    }

    if (typeof length === 'function') {
      cb = length;
      length = 1;
    }

    // Don't use sources[method || def] (method may be defined,
    // but it may not be a method in sources).
    var method = sources[method || ''] || sources[def];

    if (length > method.queue.length) {
      function loopit() {
        if (length > method.queue.length) {
          method.realRand(loopit);
        } else {
          var arr = [];

          while (arr.length < length) {
            arr.push(method.queue.shift());
          }

          cb(arr);
        }
      }
      method.realRand(loopit);
    } else {
      var arr = [];

      while (arr.length < length) {
        arr.push(method.queue.shift());
      }

      cb(arr);
    }
  },
  urand: function(length, method) {
    // Works like /dev/urandom, gets randomness from queue.
    // If there is not enough randomness, it gets all the avaiable randomness
    // and it asks for a seed and uses isaac.js (a CSPRNG)
    // to generate randomness from the seed to fill up the the rest of the length.
    // After doing this (only if there was not enough randomness), it fills up the queue.

    if (typeof length === 'undefined') {
      length = 1;
    }

    // Again, don't use sources[method || def].
    var method = sources[method] || sources[def];

    if (length > method.queue.length) {
      var arr = [];

      while (method.queue.length !== 0) {
        arr.push(method.queue.shift());
      }

      var seed = method.seed();

      isaac.reset();
      isaac.seed(seed);

      while (arr.length < length) {
        arr.push(isaacRound(isaac.rand()));
      }

      method.fillQueue();

      return arr;
    } else {
      var arr = [];

      while (arr.length < length) {
        arr.push(method.queue.shift());
      }

      return arr;
    }
  }
};
